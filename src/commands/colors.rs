use super::super::db_handlers::color_handlers::*;
use super::{Context, Error};
use poise::serenity_prelude::{
    Color, CreateAttachment, CreateEmbed, CreateEmbedFooter, EditRole, Mentionable, RoleId,
    Timestamp, User,
};
use poise::CreateReply;
use tokio::fs::File;

#[poise::command(slash_command, subcommands("set", "info", "steal"))]
pub async fn color(_ctx: Context<'_>) -> Result<(), Error> {
    Ok(())
}

#[poise::command(slash_command, ephemeral, guild_only)]
pub async fn set(
    ctx: Context<'_>,
    #[description = "Color code - hexadecimal (eg. 0xffaa99 | #11ffaa)"] color: String,
) -> Result<(), Error> {
    // Convert hex string to int
    let color = match u32::from_str_radix(&color.replace("0x", "").replace("#", ""), 16) {
        Ok(val) => val,
        Err(err) => {
            ctx.reply(format!("Invalid color code? err : {}", err))
                .await?;
            return Ok(());
        }
    };

    insert_or_update_color(ctx, color).await?;

    Ok(())
}

#[poise::command(slash_command, guild_only)]
pub async fn info(
    ctx: Context<'_>,
    #[description = "The user who's color info you want to see. leave blank for your own"]
    user: Option<User>,
) -> Result<(), Error> {
    let user = match user {
        Some(user) => user,
        None => ctx.author().clone(),
    };

    let conn = ctx.data().pool.acquire().await?;

    let color_role =
        get_color(conn, user.id.into(), ctx.guild_id().unwrap().into()).await?;

    match color_role {
        Some(role) => {
            let guild = ctx.guild_id().unwrap();
            let roles = guild.roles(&ctx.http()).await?;
            let role_id = RoleId::new(role.role_id);

            match roles.get(&role_id) {
                Some(role) => {
                    let emb = color_info_embed(role.colour, user).await;
                    let reply = poise::CreateReply::default().embed(emb);

                    ctx.send(reply).await?;
                }
                None => {}
            };
        }
        None => {
            ctx.reply("That user does not seem to have a color role managed by me")
                .await?;
            return Ok(());
        }
    };

    Ok(())
}

#[poise::command(slash_command, guild_only)]
pub async fn steal(
    ctx: Context<'_>,
    #[description = "The user who's color you want to steal"] user: User,
) -> Result<(), Error> {
    // see if role exists
    // get color code from db
    // set/update personal color role
    let conn = ctx.data().pool.acquire().await?;
    let uid = user.id;
    let guid = ctx.guild_id().unwrap();

    let color = match get_color(conn, uid.into(), guid.into()).await? {
        Some(c) => c.color,
        None => {
            ctx.reply("User does not seem to have a color role to steal")
                .await?;
            return Ok(());
        }
    };

    insert_or_update_color(ctx, color).await?;

    let file = File::open("attachments/steal.gif").await?;
    let attachment = CreateAttachment::file(&file, "steal.gif").await?;
    let reply = CreateReply::default()
        .attachment(attachment)
        .content(format!(
            "{} just stole {} their color!",
            ctx.author().mention(),
            user.mention()
        ));

    ctx.send(reply).await?;

    Ok(())
}

async fn color_info_embed(color: Color, user: User) -> CreateEmbed {
    let footer = CreateEmbedFooter::new("Generated by CyberBun");

    let embed = CreateEmbed::default()
        .title(format!("Color information for {}", user.name))
        .thumbnail(user.avatar_url().unwrap_or("".to_string()))
        .color(color)
        .field("Hex code:", color.hex(), false)
        .field("R", color.r().to_string(), true)
        .field("G", color.g().to_string(), true)
        .field("B", color.b().to_string(), true)
        .footer(footer)
        .timestamp(Timestamp::now());

    return embed;
}

async fn insert_or_update_color(ctx: Context<'_>, color: u32) -> Result<(), Error> {
    let name = ctx.author().name.to_string();
    let uid = ctx.author().id;

    let guid = match ctx.guild_id() {
        Some(g) => g,
        None => {
            ctx.reply("Can only be used inside a server").await?;
            return Ok(());
        }
    };

    // see if color exists
    let conn = ctx.data().pool.acquire().await?;
    let color_role = get_color(conn, uid.into(), guid.into()).await?;

    let guild = ctx.guild_id().unwrap();
    let conn = ctx.data().pool.acquire().await?;

    let new_role = EditRole::new()
        .name(name.clone())
        .hoist(false)
        .mentionable(false)
        .colour(color);

    match color_role {
        Some(color_role) => {
            // Color role exists ; edit color
            update_color_role(conn, color_role.role_id, color).await?;
            guild
                .edit_role(&ctx.http(), color_role.role_id, new_role)
                .await?;

            let mem = guild.member(&ctx.http(), uid).await?;
            mem.add_role(&ctx.http(), color_role.role_id).await?;

            let reply = CreateReply::default()
                .content("Color Updated!")
                .ephemeral(true);
            ctx.send(reply).await?;
        }
        None => {
            // Color role does not exist, create it
            let result = guild.create_role(&ctx.http(), new_role).await;

            match result {
                Ok(role) => {
                    create_color_role(conn, role.id.into(), uid.into(), guid.into(), color, name)
                        .await?;

                    // Add role incase user doesnt have it yet/anymore
                    let mem = guild.member(&ctx.http(), uid).await?;
                    mem.add_role(&ctx.http(), role.id).await?;

                    let reply = CreateReply::default()
                        .content("Color role created!")
                        .ephemeral(true);
                    ctx.send(reply).await?;
                }
                Err(err) => {
                    ctx.reply(format!("Error! : {}", err)).await?;
                }
            }
        }
    };

    Ok(())
}
