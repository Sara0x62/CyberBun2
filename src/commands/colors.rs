use std::collections::HashMap;

use super::super::db_handlers::color_handlers::*;
use super::{Context, Error};
use poise::serenity_prelude::{
    Color, Colour, CreateAttachment, CreateEmbed, CreateEmbedFooter, EditRole, Http, Member, Mentionable, Role, RoleId, Timestamp, User
};
use poise::CreateReply;
use tokio::fs::File;

#[poise::command(slash_command, subcommands("set", "info", "steal", "help"))]
pub async fn color(_ctx: Context<'_>) -> Result<(), Error> {
    Ok(())
}


/// Some basic help related to the color commands
#[poise::command(slash_command, ephemeral, guild_only)]
pub async fn help(ctx: Context<'_>) -> Result<(), Error> {
    // Display any other roles the user might have that are ranked above the color role.

    // Check if user already has a color role
    let user = ctx.author();
    let guild = ctx.guild_id().unwrap();
    let mem = guild.member(&ctx.http(), user.id.get()).await?;
    let conn = ctx.data().pool.acquire().await?;

    if let Some(col) = get_color(conn, user.id.get(), guild.get()).await? {
        // If user does - display help embed ; listing other roles that might take color priority
        let bot_avatar =  ctx.http().get_current_user().await?.avatar_url().unwrap_or("".to_string());
        let embed = help_embed(&mem, col.role_id, &ctx.http(), bot_avatar).await?;
        ctx.send(CreateReply::default().embed(embed)).await?;
    } else {
        // No color found
        ctx.reply("You dont seem to have any color roles made yet, try `/color set`").await?;
    }

    Ok(())
}

/// Setting a new color for yourself
#[poise::command(slash_command, ephemeral, guild_only)]
pub async fn set(
    ctx: Context<'_>,
    #[description = "Color code - hexadecimal (eg. 0xffaa99 | #11ffaa)"] color: String,
) -> Result<(), Error> {
    // Convert hex string to int
    let color = match u32::from_str_radix(&color.replace("0x", "").replace("#", ""), 16) {
        Ok(val) => val,
        Err(err) => {
            ctx.reply(format!("Invalid color code? err : {}", err))
                .await?;
            return Ok(());
        }
    };

    insert_or_update_color(ctx, color).await?;

    Ok(())
}


/// Color info on a given person or yourself if none given
#[poise::command(slash_command, guild_only)]
pub async fn info(
    ctx: Context<'_>,
    #[description = "The user who's color info you want to see. leave blank for your own"]
    user: Option<User>,
) -> Result<(), Error> {
    let user = match user {
        Some(user) => user,
        None => ctx.author().clone(),
    };

    let conn = ctx.data().pool.acquire().await?;

    let color_role =
        get_color(conn, user.id.into(), ctx.guild_id().unwrap().into()).await?;

    match color_role {
        Some(role) => {
            let guild = ctx.guild_id().unwrap();
            let roles = guild.roles(&ctx.http()).await?;
            let role_id = RoleId::new(role.role_id);

            match roles.get(&role_id) {
                Some(role) => {
                    let emb = color_info_embed(role.colour, user).await;
                    let reply = poise::CreateReply::default().embed(emb);

                    ctx.send(reply).await?;
                }
                None => {}
            };
        }
        None => {
            ctx.reply("That user does not seem to have a color role managed by me")
                .await?;
            return Ok(());
        }
    };

    Ok(())
}


/// Steal another user's color
#[poise::command(slash_command, guild_only)]
pub async fn steal(
    ctx: Context<'_>,
    #[description = "The user who's color you want to steal"] user: User,
) -> Result<(), Error> {
    // see if role exists
    // get color code from db
    // set/update personal color role
    let conn = ctx.data().pool.acquire().await?;
    let uid = user.id;
    let guid = ctx.guild_id().unwrap();

    let color = match get_color(conn, uid.into(), guid.into()).await? {
        Some(c) => c.color,
        None => {
            ctx.reply("User does not seem to have a color role to steal")
                .await?;
            return Ok(());
        }
    };

    insert_or_update_color(ctx, color).await?;

    let file = File::open("attachments/steal.gif").await?;
    let attachment = CreateAttachment::file(&file, "steal.gif").await?;
    let reply = CreateReply::default()
        .attachment(attachment)
        .content(format!(
            "{} just stole {} their color!",
            ctx.author().mention(),
            user.mention()
        ));

    ctx.send(reply).await?;

    Ok(())
}

async fn color_info_embed(color: Color, user: User) -> CreateEmbed {
    let footer = CreateEmbedFooter::new("Generated by CyberBun");

    let embed = CreateEmbed::default()
        .title(format!("Color information for {}", user.name))
        .thumbnail(user.avatar_url().unwrap_or("".to_string()))
        .color(color)
        .field("Hex code:", color.hex(), false)
        .field("R", color.r().to_string(), true)
        .field("G", color.g().to_string(), true)
        .field("B", color.b().to_string(), true)
        .footer(footer)
        .timestamp(Timestamp::now());

    return embed;
}

async fn help_embed(user: &Member, color_role_id: u64, http: &Http, bot_avatar: String) -> Result<CreateEmbed, Error> {
    let role_ids = &user.roles;
    let guild_roles = user.guild_id.roles(http).await?;
    let color_id = RoleId::from(color_role_id);

    let u_roles: HashMap<&RoleId, &Role>= guild_roles.iter().filter(|r|
        role_ids.contains(r.0)
    ).collect();
    let color_role_pos = u_roles.get(&color_id).unwrap().position;
    let no_color = Colour::from(0);

                    // - Title / content / false
    let mut higher: Vec<(String, String, bool)> = vec![];

    for (_, r) in u_roles.iter() {
        if r.position.gt(&color_role_pos) && r.colour.0.ne(&no_color.0) {
            higher.push( (format!("Role: {}", r.name), format!("Color: {}", r.colour.hex()), false) );
        }
    }

    let footer = CreateEmbedFooter::new("Generated by CyberBun");
    let embed = CreateEmbed::default()
    .title("Color - help")
    .description("
    Is your custom color not displaying correctly?
    The following roles if any can be overwriting the color role.
    Simply set the color for these roles to \"Default\" to fix this issue.
    ")
    .thumbnail(bot_avatar)
    .timestamp(Timestamp::now())
    .footer(footer)
    .fields(higher);

    Ok(embed)
}

async fn insert_or_update_color(ctx: Context<'_>, color: u32) -> Result<(), Error> {
    let name = ctx.author().name.to_string();
    let uid = ctx.author().id;

    let guid = match ctx.guild_id() {
        Some(g) => g,
        None => {
            ctx.reply("Can only be used inside a server").await?;
            return Ok(());
        }
    };

    // see if color exists
    let conn = ctx.data().pool.acquire().await?;
    let color_role = get_color(conn, uid.into(), guid.into()).await?;

    let guild = ctx.guild_id().unwrap();
    let conn = ctx.data().pool.acquire().await?;

    let new_role = EditRole::new()
        .name(name.clone())
        .hoist(false)
        .mentionable(false)
        .colour(color);

    match color_role {
        Some(color_role) => {
            let mut color_id = color_role.role_id;
            // Color role exists ; edit color
            update_color_role(conn, color_role.role_id, color).await?;

            // Try to edit guild role
            let res = guild
                .edit_role(&ctx.http(), color_role.role_id, new_role.clone())
                .await;

            if res.is_err() {
                // Role no longer seems to exist in the guild? - Try to create it instead then
                let result = guild.create_role(&ctx.http(), new_role).await?;

                // Update new ID in db
                let conn = ctx.data().pool.acquire().await?;
                update_color_role_id(conn, color_role.role_id, result.id.get()).await?;
                color_id = result.id.get();
            }

            let mem = guild.member(&ctx.http(), uid).await?;
            mem.add_role(&ctx.http(), color_id).await?;

            let reply = CreateReply::default()
                .content("Color Updated!")
                .ephemeral(true);
            ctx.send(reply).await?;
        }
        None => {
            // Color role does not exist, create it
            let result = guild.create_role(&ctx.http(), new_role).await;

            match result {
                Ok(role) => {
                    create_color_role(conn, role.id.into(), uid.into(), guid.into(), color, name)
                        .await?;

                    // Add role incase user doesnt have it yet/anymore
                    let mem = guild.member(&ctx.http(), uid).await?;
                    mem.add_role(&ctx.http(), role.id).await?;

                    let reply = CreateReply::default()
                        .content("Color role created!")
                        .ephemeral(true);
                    ctx.send(reply).await?;
                }
                Err(err) => {
                    ctx.reply(format!("Error! : {}", err)).await?;
                }
            }
        }
    };

    Ok(())
}
